# -*- coding: utf-8 -*-
"""Nombre de Formes Division CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wdaCOhkKXxLDd5MAoyO5KjhSUrqforvL
"""

# Commented out IPython magic to ensure Python compatibility.
#Importation librairies
import pathlib
import numpy as np
import os
import matplotlib.pyplot as plt
import random
import math
import cv2
import base64
from io import BytesIO
from PIL import Image
from tensorflow.keras.preprocessing.image import ImageDataGenerator
try:
  # %tensorflow_version only exists in Colab.
#   %tensorflow_version 2.x
except Exception:
  pass
import tensorflow as tf

from tensorflow import keras
from tensorflow.keras import layers

print(tf.__version__)

#Importation Google Drive
from google.colab import drive
drive.mount('/content/drive')

#Importation des images et formatage
#Création des catégories que le blason peut prendre, et association des blasons avec leurs catégories depuis la fonction d'isolement
CATEGORIES_NUMBER_DIVISION = ["aucun", "a", "two", "three", "four", "five"]

IMG_SIZE=50

imgs = []
class_num = []
descriptions = []


def isoleNbDivision(desc) :   
    desc = desc.replace(',', '').split(' ')

    if ("gyronny" in desc):
      index=desc.index("gyronny")
      if(index+2<len(desc) and desc[index+2] != ("over")):
        return desc[desc.index("gyronny")+2]

    if ("quarterly" in desc):
      index=desc.index("quarterly")
      if(index+2<len(desc) and desc[index+2] != ("over")):
        return desc[desc.index("quarterly")+2]

    if ("per" in desc):
      index_per = desc.index("per")

      if (desc[index_per+1] == ("bend") and desc[index_per+2] == ("sinister")):
        if(index_per+4<len(desc) and desc[index_per+4] != ("over")):
          return desc[index_per+4]
      else: 
        if(index_per+3<len(desc) and desc[index_per+3] != ("over")):
          return desc[index_per+3]

    return "aucun"
        
with open('drive/My Drive/blasons50_b64.txt') as f:
    for line in f:
        # on prend la description entière
        description_line = line.split(';')[0]

        # on prend l'image
        b64 = line.split(';')[1]
        img = Image.open(BytesIO(base64.b64decode(b64)))
        img_array = np.array(img)

        imgs.append(img_array)

        descriptions.append(description_line)

        categorie = isoleNbDivision(description_line)
        class_num.append(CATEGORIES_NUMBER_DIVISION.index(categorie))
f.closed

# Resize array, keras préfere
descriptions = np.array(descriptions).reshape((-1, 1))
imgs = np.array(imgs).reshape(-1, IMG_SIZE, IMG_SIZE, 4)
class_num = np.array(class_num).reshape((-1, 1))

print(class_num.shape)

for x in range(1, 100):
  print(descriptions[x])
  print(class_num[x])

#Données pour l'entrainement

nombre_donnees = round(len(imgs),-1)
nombre_donnees_apprentissage = int(round(nombre_donnees*0.75,-1))

X = imgs[:nombre_donnees_apprentissage]
y = class_num[:nombre_donnees_apprentissage]

# Pour les test
X_test = imgs[nombre_donnees_apprentissage:nombre_donnees]
y_test = class_num[nombre_donnees_apprentissage:nombre_donnees]

# Print----------------------------
print (len(X))
print (len(X_test))

#Création du modèle
model = tf.keras.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), padding='same', activation=tf.nn.relu,
                           input_shape=(IMG_SIZE, IMG_SIZE, 4)),
    tf.keras.layers.MaxPooling2D((2, 2), strides=2),
    tf.keras.layers.Conv2D(64, (3,3), padding='same', activation=tf.nn.relu),
    tf.keras.layers.MaxPooling2D((2, 2), strides=2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation=tf.nn.relu),
    tf.keras.layers.Dense(128, activation=tf.nn.relu),
    tf.keras.layers.Dense(6,  activation=tf.nn.softmax)
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

datagen = ImageDataGenerator(
      rescale=1.3/255,
      rotation_range=10,
      zoom_range=0.2,
      brightness_range=(0.3, 1.0),
      width_shift_range=0.1,
      fill_mode='constant',
      cval=255)

#Entrainement
model.fit_generator(
        datagen.flow(X, y, batch_size=32),
        epochs=6,
        validation_data=(X, y))

model.save("nombreFormesDivisionSayian.h5")

test_loss, test_accuracy = model.evaluate(X_test, y_test, steps=math.ceil(len(X_test)/10))
print('Accuracy on test dataset:', test_accuracy)

#Changer l'indice pour predire dans les arrays X_test et y_test
a = random.randint(0,1500)


img = X_test[a]
plt.imshow(img)
img = np.array([img],dtype="float16")
#print("Descriptions: " + descriptions[nombre_donnees_apprentissage+a])
print("Réel: " + CATEGORIES_NUMBER_DIVISION[y_test[a][0]])

predictions = model.predict(img)
print("Prédictions: " + CATEGORIES_NUMBER_DIVISION[np.argmax(predictions[0])])