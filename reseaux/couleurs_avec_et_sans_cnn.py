# -*- coding: utf-8 -*-
"""Couleurs avec et sans CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/147HNC_RxxMmrt0xu1TpMI52Q1R-i_VEJ
"""

# Commented out IPython magic to ensure Python compatibility.
#Importation des librairies
import pathlib
import numpy as np
import os
import matplotlib.pyplot as plt
import random
import math
import cv2
from tensorflow.keras.preprocessing.image import ImageDataGenerator
try:
  # %tensorflow_version only exists in Colab.
#   %tensorflow_version 2.x
except Exception:
  pass
import tensorflow as tf

from tensorflow import keras
from tensorflow.keras import layers

print(tf.__version__)

#Importation du Google Drive
from google.colab import drive
drive.mount('/content/drive')

"""##Importation des images"""

import base64
from io import BytesIO
from PIL import Image

CATEGORIES = ["argent", "azure", "gules", "or", "purpure", "sable", "vert"]
IMG_SIZE=50

descriptions = []
couleurs = []
imgs = []
class_num = []

with open('drive/My Drive/blasons50_b64.txt') as f:
    for line in f:
        # on prend la description entière
        description_line = line.split(';')[0]
        descriptions.append(description_line)

        # on prend que la couleur
        couleur = description_line.split(' ')[0]
        couleur = couleur.split(",")[0]
        couleurs.append(couleur)

        # on prend l'image
        b64 = line.split(';')[1]
        img = Image.open(BytesIO(base64.b64decode(b64)))
        img_array = np.array(img)
        #resize array
        new_array=cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))
        imgs.append(new_array)

        class_num.append(CATEGORIES.index(couleur))
f.closed

# Resize array, keras préfere
descriptions = np.array(descriptions).reshape((-1, 1))
couleurs = np.array(couleurs).reshape((-1, 1))
imgs = np.array(imgs).reshape(-1, IMG_SIZE, IMG_SIZE, 4)
class_num = np.array(class_num).reshape((-1, 1))

plt.imshow(imgs[3])
print(descriptions.shape)
print(couleurs.shape)
print(class_num[3])
print(couleurs[3])

# Pour l'entrainement
X = imgs[:65000]
y = class_num[:65000]

plt.imshow(imgs[0])
print(class_num[0])

# Pour les test
X_test = imgs[65000:75000]
y_test = class_num[65000:75000]

# Print----------------------------
print (len(X))
print (len(y))

"""## Avec CNN"""

#Création du modèle
model1 = tf.keras.Sequential([
    tf.keras.layers.Conv2D(4, (3,3), padding='same', activation=tf.nn.relu,
                           input_shape=(IMG_SIZE, IMG_SIZE, 4)),
    tf.keras.layers.MaxPooling2D((2, 2), strides=2),
    tf.keras.layers.Conv2D(8, (3,3), padding='same', activation=tf.nn.relu),
    tf.keras.layers.MaxPooling2D((2, 2), strides=2),
    tf.keras.layers.Flatten(),
    #tf.keras.layers.Flatten(input_shape=(IMG_SIZE, IMG_SIZE, 4)),
    tf.keras.layers.Dense(128, activation=tf.nn.relu),
    tf.keras.layers.Dense(7,  activation=tf.nn.softmax)
])

model1.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

datagen = ImageDataGenerator(
      rescale=1.3/255,
      rotation_range=10,
      zoom_range=0.2,
      brightness_range=(0.3, 1.0),
      width_shift_range=0.1,
      fill_mode='constant',
      cval=255)

#Entrainement
model1.fit_generator(
        datagen.flow(X, y),
        epochs=6)

model1.save('couleursSayian.h5')

"""## Sans CNN et sans transformations"""

model2 = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(IMG_SIZE, IMG_SIZE, 4)),
    tf.keras.layers.Dense(128, activation=tf.nn.relu),
    tf.keras.layers.Dense(7,  activation=tf.nn.softmax)
])

model2.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model2.fit(X, y, epochs=6)

"""## Validation et prédictions"""

test_loss, test_accuracy = model1.evaluate(X_test, y_test, steps=math.ceil(len(X_test)/50))
print('Accuracy on test dataset:', test_accuracy)

test_loss, test_accuracy = model2.evaluate(X_test, y_test, steps=math.ceil(len(X_test)/50))
print('Accuracy on test dataset:', test_accuracy)

#Changer l'indice pour predire dans les arrays X_test et y_test

a = random.randint(0,1500)


img = X_test[a]
plt.imshow(img)
img = np.array([img],dtype="float16")
print(CATEGORIES[y_test[a][0]])

predictions = model1.predict(img)
print(CATEGORIES[np.argmax(predictions[0])])

img_trans = datagen.random_transform(X[0])
plt.imshow(img_trans)